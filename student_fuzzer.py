from fuzzingbook import GreyboxFuzzer as gbf
from fuzzingbook import Coverage as cv
from fuzzingbook import MutationFuzzer as mf
from fuzzingbook.Fuzzer import Fuzzer
import traceback
import numpy as np
import time
from typing import List, Set, Any, Tuple, Dict, Union
import random
from bug import entrypoint
from bug import get_initial_corpus



class Seed:
    """Represent an input with additional attributes"""

    def __init__(self, data: str) -> None:
        """Initialize from seed data"""
        self.data = data

        # These will be needed for advanced power schedules
        self.coverage: Set[cv.Location] = set()
        self.distance: Union[int, float] = -1
        self.energy = 0.0
        self.parent = ""
        self.mut_index = 0
        self.m_prob = {"delete":0.33,"insert":0.33,"flip":0.33}

    def __str__(self) -> str:
        """Returns data as string representation of the seed"""
        return self.data

    __repr__ = __str__


class Mutator:
    """Mutate strings"""

    def __init__(self) -> None:
        """Constructor"""
        self.mutators = [
            self.delete_random_character,
            self.insert_random_character,
            self.flip_random_character
        ]

class Mutator(Mutator):
    def insert_random_character(self, s: str) -> str:
        """Returns s with a random character inserted"""
        pos = random.randint(0, len(s))
        random_character = chr(random.randrange(32, 127))
        return s[:pos] + random_character + s[pos:]

    def delete_random_character(self, s: str) -> str:
        """Returns s with a random character deleted"""
        if s == "":
            return self.insert_random_character(s)

        pos = random.randint(0, len(s) - 1)
        return s[:pos] + s[pos + 1:]

    def flip_random_character(self, s: str) -> str:
        """Returns s with a random bit flipped in a random position"""
        if s == "":
            return self.insert_random_character(s)

        pos = random.randint(0, len(s) - 1)
        c = s[pos]
        bit = 1 << random.randint(0, 6)
        new_c = chr(ord(c) ^ bit)
        return s[:pos] + new_c + s[pos + 1:]

    def mutate(self, inp: Seed) -> Any:  # can be str or Seed (see below)
        """Return s with a random mutation applied. Can be overloaded in subclasses."""
        #print(f"data to mutate: {inp}")
        #print(type(inp))
        prob_list = [i for i in inp.m_prob.values()]
        #print(prob_list)
        mutator = random.choices(self.mutators, weights=prob_list)[0]
        #print(mutator)
        #print(self.mutators.index(mutator))
        m=mutator(inp.data)
        s = Seed(str(m))
        #s.parent = inp.data
        s.mut_index = self.mutators.index(mutator)
        s.m_prob = inp.m_prob
        return s



class AdvancedMutationFuzzer(Fuzzer):
    """Base class for mutation-based fuzzing."""

    def __init__(self, seeds: List[str],
                 mutator: Mutator,
                 schedule: gbf.PowerSchedule) -> None:
        """Constructor.
        `seeds` - a list of (input) strings to mutate.
        `mutator` - the mutator to apply.
        `schedule` - the power schedule to apply.
        """
        self.seeds = seeds
        self.mutator = mutator
        self.schedule = schedule
        self.inputs: List[str] = []
        self.reset()

    def reset(self) -> None:
        """Reset the initial population and seed index"""
        self.population = list(map(lambda x: Seed(x), self.seeds))
        self.seed_index = 0

    def create_candidate(self) -> str:
        """Returns an input generated by fuzzing a seed in the population"""
        seed = self.schedule.choose(self.population)

        # Stacking: Apply multiple mutations to generate the candidate
        #print(type(seed))
        c_parent = seed
        candidate = seed
        trials = min(len(candidate.data), 1 << random.randint(1, 5))
        for i in range(trials):
            candidate = self.mutator.mutate(candidate)
        candidate.parent= c_parent
        return candidate

    def fuzz(self) -> str:
        """Returns first each seed once and then generates new inputs"""
        #print(len(self.seeds))
        if self.seed_index < len(self.seeds):
            # Still seeding
            self.inp = self.seeds[self.seed_index]
            self.seed_index += 1
            self.inputs.append(self.inp)
        else:
            # Mutating
            for i in range(3*len(self.population)):
                self.inp = self.create_candidate()
                self.inputs.append(self.inp)
        #print(self.inputs)
        return self.inp

class GreyboxFuzzer(AdvancedMutationFuzzer):
    """Coverage-guided mutational fuzzing."""

    def reset(self):
        """Reset the initial population, seed index, coverage information"""
        super().reset()
        self.coverages_seen = set()
        #self.population = []  # population is filled during greybox fuzzing

    def run(self, runner: mf.FunctionCoverageRunner) -> Tuple[Any, str]:
        """Run function(inp) while tracking coverage.
           If we reach new coverage,
           add inp to population and its coverage to population_coverage
        """
        result, outcome = super().run(runner)
        new_coverage = frozenset(runner.coverage())
        if new_coverage not in self.coverages_seen and str(self.inp) not in self.population:
            #print("We have new coverage")
            #print(self.inp)
            #print(type(self.inp))
            if isinstance(self.inp, str):
                seed = Seed(self.inp) 
                #print("Its a string")
            else:
                #print("Its a Seed")
                seed = self.inp
                self.inp.m_prob =  {"delete":0.33,"insert":0.33,"flip":0.33}
                p_s = seed.parent 
                #print(f"Parent: {p_s}")
                m_index = seed.mut_index 
                #print(f"Population: {self.population}")
                #print(type(self.population))
                for s in self.population: 
                    #print(s.data)
                    if str(s.data) == str(p_s):
                        #print("Got a new seed")
                        #print(f"Parent: {s.data}")
                        op = m_op_list[m_index]
                        s.m_prob[op]+=0.35 
                        for k in range(3):
                            if k!=m_index:
                                op_ = m_op_list[k]
                                s.m_prob[op_]-=0.25
                        norm = sum(list(s.m_prob.values()))
                        for k in range(3):
                            op_ = m_op_list[k]
                            s.m_prob[op_]/=norm
                        #print(s.m_prob.values())
                        #s.m_prob.values() =s.m_prob.values()/ sum(s.m_prob.values())
            seed.coverage = runner.coverage()
            self.coverages_seen.add(new_coverage)
            self.population.append(seed)
            

        return (result, outcome)

if __name__ == "__main__":
    seed_inputs = get_initial_corpus()
    m_op_list = ["delete","insert","flip"]
    #seed_inputs = [Seed(inp) for inp in seed_inputs]
    #print(seed_inputs[0].m_prob)
    greybox_fuzzer = GreyboxFuzzer(seed_inputs, Mutator(), gbf.PowerSchedule())

    start = time.time()
    greybox_fuzzer.runs(mf.FunctionCoverageRunner(entrypoint), trials=100000000)
    end = time.time()

    print(greybox_fuzzer.population)
    _, greybox_coverage = cv.population_coverage(greybox_fuzzer.inputs, entrypoint)
    print(max(greybox_coverage))
